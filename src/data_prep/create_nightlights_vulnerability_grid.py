#!/usr/bin/env python3
"""
Preprocess nightlights data to grid cells for faster vulnerability computation.
"""

import os
import numpy as np
import geopandas as gpd
import rasterio
from shapely.geometry import box
from src.utils.config_utils import get_config_value, load_config
from src.utils.path_utils import get_data_path
from src.utils.hurricane_geom import get_nicaragua_boundary


def aggregate_nightlights_to_grid(nightlights_path, grid_resolution=0.1):
    """
    Aggregate nightlights data to grid cells.

    Args:
        nightlights_path: Path to the nightlights GeoTIFF file
        grid_resolution: Grid resolution in degrees

    Returns:
        GeoDataFrame with grid cells and aggregated nightlights values
    """
    print(f"Aggregating nightlights to {grid_resolution}¬∞ grid...")

    # Load nightlights data
    with rasterio.open(nightlights_path) as src:
        nightlights_data = src.read(1)
        transform = src.transform
        crs = src.crs

    # Get Nicaragua boundary for grid bounds
    nicaragua_gdf = get_nicaragua_boundary()
    bounds = nicaragua_gdf.total_bounds
    minx, miny, maxx, maxy = bounds

    # Create grid
    grid_cells = []
    x_coords = np.arange(minx, maxx, grid_resolution)
    y_coords = np.arange(miny, maxy, grid_resolution)

    print(f"Creating grid with {len(x_coords)} x {len(y_coords)} cells...")

    for x in x_coords:
        for y in y_coords:
            grid_cells.append(box(x, y, x + grid_resolution, y + grid_resolution))

    grid_gdf = gpd.GeoDataFrame(grid_cells, columns=["geometry"], crs="EPSG:4326")

    # Aggregate nightlights to grid cells
    from rasterio.features import geometry_mask

    nightlights_values = []
    total_cells = len(grid_gdf)

    print(f"Aggregating nightlights for {total_cells} grid cells...")

    for i, cell in enumerate(grid_gdf.geometry):
        if i % 100 == 0:
            print(f"  Processing cell {i+1}/{total_cells}")

        # Create mask for the cell
        mask = geometry_mask(
            [cell],
            out_shape=nightlights_data.shape,
            transform=transform,
            invert=True,
        )

        # Calculate sum of nightlights values in the cell
        cell_values = nightlights_data[mask]
        if len(cell_values) > 0:
            sum_value = np.sum(cell_values)
        else:
            sum_value = 0

        nightlights_values.append(sum_value)

    grid_gdf["nightlights_sum"] = nightlights_values

    print(f"‚úÖ Nightlights aggregation completed!")
    print(f"   Grid shape: {len(grid_gdf)} cells")
    print(
        f"   Nightlights range: {grid_gdf['nightlights_sum'].min():.2f} - {grid_gdf['nightlights_sum'].max():.2f}"
    )
    print(f"   Total nightlights: {grid_gdf['nightlights_sum'].sum():.2f}")

    return grid_gdf


def aggregate_population_to_grid(grid_gdf, grid_resolution=0.1):
    """
    Aggregate population data to the same grid cells.

    Args:
        grid_gdf: GeoDataFrame with grid cells
        grid_resolution: Grid resolution in degrees

    Returns:
        GeoDataFrame with population values added
    """
    print("Aggregating population data to grid...")

    # Load population data
    base_path = get_data_path("data/raw/census")
    age_groups = list(range(0, 85, 5))  # All age groups for total population
    files_to_load = []

    for age in age_groups:
        ffile = base_path / f"nic_f_{age}_2020_constrained_UNadj.tif"
        mfile = base_path / f"nic_m_{age}_2020_constrained_UNadj.tif"

        if ffile.exists():
            files_to_load.append(str(ffile))
        if mfile.exists():
            files_to_load.append(str(mfile))

    if not files_to_load:
        raise FileNotFoundError("No population raster files found!")

    # Sum all population rasters
    with rasterio.open(files_to_load[0]) as src:
        ref_transform = src.transform
        ref_crs = src.crs
        ref_shape = src.read(1).shape

    combined = np.zeros(ref_shape, dtype=np.float32)
    for fpath in files_to_load:
        with rasterio.open(fpath) as src:
            data = src.read(1)
            data = np.where(data <= -99999, 0, data)
            combined += data

    # Aggregate population to grid cells
    from rasterio.features import geometry_mask

    population_values = []
    total_cells = len(grid_gdf)

    print(f"Aggregating population for {total_cells} grid cells...")

    for i, cell in enumerate(grid_gdf.geometry):
        if i % 100 == 0:
            print(f"  Processing cell {i+1}/{total_cells}")

        # Create mask for the cell
        mask = geometry_mask(
            [cell],
            out_shape=combined.shape,
            transform=ref_transform,
            invert=True,
        )

        # Calculate total population in the cell
        cell_population = combined[mask].sum()
        population_values.append(cell_population)

    grid_gdf["population_total"] = population_values

    print(f"‚úÖ Population aggregation completed!")
    print(
        f"   Population range: {grid_gdf['population_total'].min():.0f} - {grid_gdf['population_total'].max():.0f}"
    )
    print(f"   Total population: {grid_gdf['population_total'].sum():.0f}")

    return grid_gdf


def compute_vulnerability_index(grid_gdf, epsilon=1.0):
    """
    Compute vulnerability index: population / (nightlights + epsilon)

    Args:
        grid_gdf: GeoDataFrame with population and nightlights data
        epsilon: Small value to avoid division by zero

    Returns:
        GeoDataFrame with vulnerability index added
    """
    print("Computing vulnerability index...")

    # Compute vulnerability index
    vulnerability_index = grid_gdf["population_total"] / (
        grid_gdf["nightlights_sum"] + epsilon
    )

    # Handle division by zero and invalid values
    vulnerability_index = np.where(
        np.isnan(vulnerability_index) | np.isinf(vulnerability_index),
        0,
        vulnerability_index,
    )

    grid_gdf["vulnerability_index"] = vulnerability_index

    print(f"‚úÖ Vulnerability index computed!")
    print(
        f"   Vulnerability range: {vulnerability_index.min():.2f} - {vulnerability_index.max():.2f}"
    )
    print(f"   Mean vulnerability: {vulnerability_index.mean():.2f}")

    return grid_gdf


def identify_impact_prone_cells(grid_gdf, threshold_percentile=75.0):
    """
    Identify impact-prone cells based on vulnerability index threshold.

    Args:
        grid_gdf: GeoDataFrame with vulnerability index
        threshold_percentile: Percentile threshold for impact-prone classification

    Returns:
        GeoDataFrame with impact-prone classification added
    """
    print(
        f"Identifying impact-prone cells (threshold: {threshold_percentile}th percentile)..."
    )

    # Get Nicaragua boundary to filter cells
    nicaragua_gdf = get_nicaragua_boundary()

    # Filter to cells that intersect with Nicaragua and have actual data
    cells_with_data = grid_gdf[
        (grid_gdf["population_total"] > 0) & (grid_gdf["vulnerability_index"] > 0)
    ]

    # Calculate threshold based on percentile of cells with actual data
    vulnerability_values = cells_with_data["vulnerability_index"]
    threshold = np.percentile(vulnerability_values, threshold_percentile)

    # Create binary mask for impact-prone cells
    impact_prone_mask = grid_gdf["vulnerability_index"] >= threshold

    grid_gdf["impact_prone"] = impact_prone_mask

    print(f"‚úÖ Impact-prone cells identified!")
    print(f"   Cells with data: {len(cells_with_data)}")
    print(f"   Threshold: {threshold:.2f}")
    print(
        f"   Impact-prone cells: {np.sum(impact_prone_mask)} out of {len(impact_prone_mask)} ({np.sum(impact_prone_mask)/len(impact_prone_mask)*100:.1f}%)"
    )

    return grid_gdf


def main():
    """Main function to preprocess nightlights and population data to grid."""

    # Load configuration
    config = load_config("config/impact_analysis_config.yaml")

    print("=" * 60)
    print("NIGHTLIGHTS GRID PREPROCESSING")
    print("=" * 60)

    # Configuration
    grid_resolution = get_config_value(
        config, "impact_analysis.grid.resolution_degrees", 0.1
    )
    epsilon = get_config_value(config, "impact_analysis.impact_prone.epsilon", 1.0)
    threshold_percentile = get_config_value(
        config, "impact_analysis.impact_prone.threshold_percentile", 75.0
    )

    # Input and output paths
    nightlights_path = get_data_path(
        "data/preprocessed/nightlights/processed/nightlights_nicaragua_average.tif"
    )
    output_path = get_data_path(
        "data/preprocessed/nightlights/processed/nightlights_population_grid.gpkg"
    )

    if not os.path.exists(nightlights_path):
        print(f"‚ùå Nightlights data not found: {nightlights_path}")
        print("Please run the nightlights processing pipeline first.")
        return

    # Step 1: Aggregate nightlights to grid
    grid_gdf = aggregate_nightlights_to_grid(nightlights_path, grid_resolution)

    # Step 2: Aggregate population to grid
    grid_gdf = aggregate_population_to_grid(grid_gdf, grid_resolution)

    # Step 3: Compute vulnerability index
    grid_gdf = compute_vulnerability_index(grid_gdf, epsilon)

    # Step 4: Identify impact-prone cells
    grid_gdf = identify_impact_prone_cells(grid_gdf, threshold_percentile)

    # Step 5: Save preprocessed grid
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    grid_gdf.to_file(output_path, driver="GPKG")

    print(f"\n‚úÖ Preprocessing completed!")
    print(f"   Output saved to: {output_path}")
    print(f"   Grid shape: {len(grid_gdf)} cells")
    print(f"   Columns: {list(grid_gdf.columns)}")

    # Print summary statistics
    print(f"\nüìä SUMMARY STATISTICS:")
    print(f"   Nightlights total: {grid_gdf['nightlights_sum'].sum():.2f}")
    print(f"   Population total: {grid_gdf['population_total'].sum():.0f}")
    print(f"   Vulnerability index mean: {grid_gdf['vulnerability_index'].mean():.2f}")
    print(
        f"   Impact-prone cells: {grid_gdf['impact_prone'].sum()} ({grid_gdf['impact_prone'].sum()/len(grid_gdf)*100:.1f}%)"
    )


if __name__ == "__main__":
    main()
